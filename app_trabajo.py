# -*- coding: utf-8 -*-
"""app_trabajo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rxt7sH06MrFsSjkDtV82kmlEN-a7cRFj
"""



# app.py

import streamlit as st
import datetime
import pickle
import pandas as pd
import numpy as np

st.set_page_config(page_title="Predicción de SKU", layout="centered")
st.title("Predicción de SKU")

# ----------------------
# Config
# ----------------------
PICKLE_PATH = "modelo-reg-resultados.pkl"  # ajusta si tu archivo tiene otro nombre

# ----------------------
# Funciones utilitarias
# ----------------------
@st.cache_data(show_spinner=False)
def cargar_payload(path=PICKLE_PATH):
    with open(path, "rb") as f:
        payload = pickle.load(f)
    return payload

def extraer_skus(payload):
    """Extrae SKUs desde payload['resultados'] si hay DataFrames; fallback a lista mínima."""
    skus = set()
    resultados = payload.get("resultados", {}) if isinstance(payload, dict) else {}
    for name, info in resultados.items():
        out = info.get("output") if isinstance(info, dict) else info
        # caso: output es DataFrame
        if isinstance(out, pd.DataFrame):
            for col in ["Sku", "sku", "SKU"]:
                if col in out.columns:
                    skus.update(out[col].astype(str).unique().tolist())
        # caso: output es tuple/list (df_resultados, df_metricas)
        if isinstance(out, (list, tuple)) and len(out) >= 1 and isinstance(out[0], pd.DataFrame):
            df0 = out[0]
            for col in ["Sku", "sku", "SKU"]:
                if col in df0.columns:
                    skus.update(df0[col].astype(str).unique().tolist())
        # caso: modelos por sku -> buscar keys
        if isinstance(out, dict):
            # si hay modelos por sku guardados como dict
            if "modelos_por_sku" in out and isinstance(out["modelos_por_sku"], dict):
                skus.update([str(k) for k in out["modelos_por_sku"].keys()])
    if not skus:
        # fallback: lista mínima; reemplaza por tu lista completa si lo prefieres
        skus = {"01BL012K20", "01BL012KC22H", "01BL012KF23H"}
    return sorted(list(skus))

def buscar_prediccion_en_df(df, sku, fecha_seleccionada):
    """Buscar fila de predicción en df por sku y fecha (robusto)."""
    if df is None or df.empty:
        return None

    # identificar columnas
    col_sem = None
    for c in ["semana", "Semana", "fecha", "date"]:
        if c in df.columns:
            col_sem = c
            break
    col_sku = None
    for c in ["Sku", "sku", "SKU"]:
        if c in df.columns:
            col_sku = c
            break
    if col_sku is None:
        return None

    df_f = df[df[col_sku].astype(str) == str(sku)].copy()
    if df_f.empty:
        return None

    if col_sem is None:
        return df_f

    # convertir columna fecha
    try:
        df_f[col_sem + "_dt"] = pd.to_datetime(df_f[col_sem])
    except Exception:
        try:
            df_f[col_sem + "_dt"] = df_f[col_sem]
        except Exception:
            return None

    target = pd.to_datetime(fecha_seleccionada)
    match = df_f[df_f[col_sem + "_dt"] == target]
    if not match.empty:
        return match
    # nearest
    df_f = df_f.sort_values(col_sem + "_dt")
    dif = (df_f[col_sem + "_dt"] - target).abs()
    nearest = df_f.loc[dif.idxmin()]
    return pd.DataFrame([nearest])

# ----------------------
# Cargar payload
# ----------------------
try:
    payload = cargar_payload()
except FileNotFoundError:
    st.error(f"No se encontró el archivo {PICKLE_PATH}. Coloca el pkl en el mismo directorio o ajusta PICKLE_PATH.")
    st.stop()
except Exception as e:
    st.error(f"Error cargando el pkl: {e}")
    st.stop()

# ----------------------
# Extraer opciones
# ----------------------
resultados = payload.get("resultados", {}) if isinstance(payload, dict) else {}
metodos_disponibles = sorted(list(resultados.keys()))
if not metodos_disponibles:
    st.error("No hay métodos/resultados guardados en el pkl bajo payload['resultados'].")
    st.stop()

sku_options = extraer_skus(payload)

# ----------------------
# Inputs de usuario
# ----------------------
col1, col2 = st.columns([2, 3])

with col1:
    metodo_seleccionado = st.selectbox("Selecciona el método/modelo", metodos_disponibles, index=0)
    st.write("Método seleccionado:", metodo_seleccionado)

with col2:
    Sku = st.selectbox("Selecciona SKU", sku_options)

min_date = datetime.date(2022, 1, 2)
max_date = datetime.date(2025, 8, 24)
semana = st.slider(
    "Selecciona una semana (cada 7 días)",
    min_value=min_date,
    max_value=max_date,
    value=min_date,
    step=datetime.timedelta(weeks=1)
)
st.write("Fecha (inicio de la semana) seleccionada:", semana)

st.markdown("---")

# ----------------------
# Obtener salida seleccionada
# ----------------------
info_sel = resultados.get(metodo_seleccionado)
out = info_sel.get("output") if isinstance(info_sel, dict) else info_sel

# Caso A: out es DataFrame o (df_resultados, df_metricas)
candidate_df = None
if isinstance(out, pd.DataFrame):
    candidate_df = out
elif isinstance(out, (list, tuple)) and len(out) >= 1 and isinstance(out[0], pd.DataFrame):
    candidate_df = out[0]

if candidate_df is not None:
    found = buscar_prediccion_en_df(candidate_df, Sku, semana)
    if found is not None and not found.empty:
        st.success(f"Predicción encontrada en DataFrame del método: {metodo_seleccionado}")
        st.dataframe(found)
        # mostrar probables columnas de predicción
        for col in ["prediccion_ma", "prediccion", "prediccion_ma_val", "pred", "y_pred"]:
            if col in found.columns:
                st.write("Predicción (ej.):", found[col].values)
                break
    else:
        st.warning(f"No se encontró fila para SKU={Sku} y semana={semana} en el DataFrame de {metodo_seleccionado}.")
        st.write("Puedes revisar el contenido del DataFrame guardado para este método con:")
        if st.button("Mostrar preview del DataFrame guardado"):
            st.dataframe(candidate_df.head(30))
else:
    # Caso B: out no es DataFrame, intentar usar como modelo/objeto
    modelo_obj = out
    # detectar si es dict con modelos por sku
    if isinstance(modelo_obj, dict) and "modelos_por_sku" in modelo_obj and isinstance(modelo_obj["modelos_por_sku"], dict):
        modelos_por_sku = modelo_obj["modelos_por_sku"]
        modelo_sku = modelos_por_sku.get(Sku)
        if modelo_sku is None:
            st.warning(f"No hay modelo guardado para el SKU {Sku} en 'modelos_por_sku'.")
        else:
            st.info(f"Se encontró un modelo para el SKU {Sku}. Intentando predecir con .predict()...")
            if hasattr(modelo_sku, "predict"):
                # intentar usar meta['features'] para formar X_row si está disponible
                meta = payload.get("meta", {}) if isinstance(payload, dict) else {}
                features_req = meta.get("variables") or meta.get("features") or meta.get("feature_names")
                if features_req:
                    st.write("Variables requeridas por el modelo:", features_req)
                    valores = {}
                    with st.form("form_features"):
                        for feat in features_req:
                            valores[feat] = st.number_input(f"{feat}", value=0.0, key=f"{metodo_seleccionado}_{Sku}_{feat}")
                        submitted = st.form_submit_button("Predecir")
                    if submitted:
                        X_row = pd.DataFrame([valores])
                        try:
                            y_pred = modelo_sku.predict(X_row)
                            st.success("Predicción:")
                            st.write(y_pred)
                        except Exception as e:
                            st.error(f"Error en modelo.predict: {e}")
                else:
                    st.warning("No se encontró la lista de features en payload['meta']. Debes construir X_row manualmente.")
                    st.code("""
# Ejemplo de cómo preparar X_row:
X_row = pd.DataFrame([{
    'feature_a': valor_a,
    'feature_b': valor_b,
    ...
}])
y_pred = modelo_sku.predict(X_row)
""")
            else:
                st.warning(f"El objeto del SKU {Sku} no tiene método .predict(). Tipo: {type(modelo_sku)}")
    elif hasattr(modelo_obj, "predict"):
        # modelo global (no por sku)
        st.info(f"El objeto guardado para '{metodo_seleccionado}' parece un modelo con .predict().")
        meta = payload.get("meta", {}) if isinstance(payload, dict) else {}
        features_req = meta.get("variables") or meta.get("features") or meta.get("feature_names")
        if features_req:
            st.write("Variables requeridas por el modelo:", features_req)
            valores = {}
            with st.form("form_features_global"):
                for feat in features_req:
                    valores[feat] = st.number_input(f"{feat}", value=0.0, key=f"{metodo_seleccionado}_{feat}")
                submitted = st.form_submit_button("Predecir global")
            if submitted:
                X_row = pd.DataFrame([valores])
                try:
                    y_pred = modelo_obj.predict(X_row)
                    st.success("Predicción:")
                    st.write(y_pred)
                except Exception as e:
                    st.error(f"Error en modelo.predict: {e}")
        else:
            st.warning("No se encontró la lista de features en payload['meta']. Debes construir X_row manualmente.")
            st.code("""
# Ejemplo de cómo preparar X_row:
X_row = pd.DataFrame([{
    'feature_a': valor_a,
    'feature_b': valor_b,
    ...
}])
y_pred = modelo_obj.predict(X_row)
""")
    else:
        st.warning(f"El contenido guardado en '{metodo_seleccionado}' no es ni DataFrame ni un modelo con .predict().")
        st.write("Tipo:", type(out))
        if st.button("Mostrar contenido (texto)"):
            st.write(str(out)[:1000])

st.markdown("---")
st.write("Ejecuta `streamlit run app.py` para abrir la app. Si necesitas que adapte la app a un formato específico del pkl, pega aquí el resultado de:")
st.code("""
import pickle
with open("modelo-reg-resultados.pkl","rb") as f:
    payload = pickle.load(f)
print(payload.keys())
print(payload['resultados'].keys())
# ejemplo para un método
info = payload['resultados'].get('media_movil_por_sku')
print(type(info))
print(type(info.get('output')))
""")
